import { Musixmatch } from './Musixmatch';
import { awaitLists, observe } from './index';
import { getLyricLibLyrics, LrcLibResponse } from './LrcLib';
import { LyricsResponse } from './LyricUtils';
import { getYoutubeCache, setYoutubeCache } from './YoutubeCache';

const youtubeSnippetAPI = "https://www.googleapis.com/youtube/v3/videos";

type videoMetaType = {
    kind: string,
    etag: string,
    items: [{
        contentDetails: {
            duration: string // ISO 8601
        },
        kind: string,
        etag: string,
        id: string,
        snippet: {
            publishedAt: string,
            channelId: string
            title: string,
            description: string,
            channelType: string
            defaultLanguage: string,
            tags: string[],
            channelTitle: string,
        }
    }]
}

function sleep(milliseconds: number) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}

const cache = caches.default;

export async function getLyrics(request: Request, env: Env): Promise<Response> {
    let cachedResponse = await cache.match(request.url);
    if (cachedResponse) {
        observe({ usingCachedLyrics: true });
        return cachedResponse;
    } else {
        observe({ usingCachedLyrics: false });
    }

    // if (request.headers.get('User-Agent')?.includes("Safari")) {
    //     await sleep(20000);
    //     return new Response(JSON.stringify({}));
    // }

    let params = new URL(request.url).searchParams;
    let artist: string | null | undefined = params.get('artist');
    let song: string | null | undefined = params.get('song');
    let album: string | null | undefined = params.get('album');
    let duration: string | null | undefined = params.get('duration');
    let parsedSongAndArtist: string | null = null;
    let videoId = params.get("videoId");
    let alwaysFetchMetadata = params.get('alwaysFetchMetadata')?.toLowerCase() === 'true';
    let useLrcLib = params.get('useLrcLib')?.toLowerCase() === 'true';

    observe({endpoint: request.url});

    let description: string | null = null;
    const mx = new Musixmatch();


    // we'll use this to make sure we control the formatting of multi-artists
    let artists: string[] = [];
    if (artist) {
        artists = artist.split(',')
            .flatMap(a => a.split('&'))
            // .flatMap(a => a.split('and'))
            .map(a => a.trim()).filter(a => a.length > 0);
    }

    observe({ 'numArtists': artists.length, 'artists': artists });

    if (!videoId) {
        return new Response(JSON.stringify("Invalid Video Id"), { status: 400 });
    }

    // song = cleanupText(song);
    // artist = cleanupText(artist);

    let tokenPromise = mx.getToken();

    if (alwaysFetchMetadata || !song || song.trim().length === 0 || artists.length === 0 || !album || album.length === 0) {
        const cachedYoutubeData = await getYoutubeCache(videoId);
        if (cachedYoutubeData) {
            song = cachedYoutubeData.song;
            artists = cachedYoutubeData.artists ?? [];
            artist = artists.join(', ');
            album = cachedYoutubeData.album;
            duration = cachedYoutubeData.duration?.toString();
        } else {
            let snippetUrl = new URL(youtubeSnippetAPI);
            snippetUrl.searchParams.set('id', videoId);
            snippetUrl.searchParams.set('key', env.GOOGLE_API_KEY);
            snippetUrl.searchParams.set('part', 'snippet,contentDetails');

            const response = await fetch(snippetUrl);
            if (response.status === 200) {
                const videoMeta: videoMetaType = await response.json();

                if (videoMeta && videoMeta.items && videoMeta.items.length > 0
                    && videoMeta.items[0] && videoMeta.items[0].snippet && videoMeta.items[0].contentDetails) {
                    let snippet = videoMeta.items[0].snippet;
                    if (snippet.description && snippet.description.endsWith('Auto-generated by YouTube.')) {
                        description = snippet.description;
                        let desc = snippet.description.split('\n');
                        if (desc.length > 4) {
                            parsedSongAndArtist = desc[2];
                            album = desc[4];
                        }

                        if (parsedSongAndArtist) {
                            let splitSongAndArtist = parsedSongAndArtist.split('·');
                            song = splitSongAndArtist[0].trim();

                            splitSongAndArtist.shift();

                            // Check that the original artist is in the metadata list
                            let newArtists = splitSongAndArtist;
                            if (newArtists.length > 3 && newArtists.length > artists.length) {
                                // We have a lot of artists. This probably means writers/etc are also here.
                                if (snippet.channelTitle && snippet.channelTitle.endsWith('- Topic')) {
                                    // Use the channel title instead
                                    newArtists = [snippet.channelTitle.substring(0, snippet.channelTitle.length - 7).trim()];
                                } else {
                                    newArtists = [newArtists[0]];
                                }
                            }

                            if (artists.length == 0 || newArtists.includes(artists[0])) {
                                artists = newArtists;
                                artist = artists.join(', ');
                            }
                        }
                    }

                    let contentDetails = videoMeta.items[0].contentDetails;
                    if (contentDetails && contentDetails.duration) {
                        const match = contentDetails.duration.match(/PT(?:(\d+)M)?(?:(\d+)S)?/);
                        if (match) {
                            const minutes = match[1] ? parseInt(match[1], 10) : 0;
                            const seconds = match[2] ? parseInt(match[2], 10) : 0;

                            duration = String(60 * minutes + seconds);
                        }
                    }

                    awaitLists.add(setYoutubeCache({
                        video_id: videoId,
                        song,
                        artists,
                        album,
                        duration: duration ? parseInt(duration) : null
                    }));
                }
            }
        }
    }

    if (!song) {
        return new Response(JSON.stringify({
            message: "A Song wasn't provided and couldn't be inferred",
            song,
            artist,
            album,
            duration,
            parsedSongAndArtist,
            videoId,
            description,
        }), { status: 400 });
    }

    if (!artist) {
        return new Response(JSON.stringify({
            message: "An Artist wasn't provided and couldn't be inferred",
            song,
            artist,
            album,
            duration,
            parsedSongAndArtist,
            videoId,
            description,
        }), { status: 400 });
    }


    let response = {
        song,
        artist,
        album,
        duration,
        parsedSongAndArtist,
        videoId,
        description,
        debugInfo: null as any,
        musixmatchWordByWordLyrics: null as any,
        musixmatchSyncedLyrics: null as any,
        lrclibSyncedLyrics: null as any,
        lrclibPlainLyrics: null as any
    };

    let artistAlbumSongCombos: { artist: string, song: string, album: string | null }[] = [
        {
            artist: artists.join(', '), album, song
        }
    ];

    // if (artists.length > 1) {
    //     artistAlbumSongCombos.push({
    //         artist: artists[0],
    //         album,
    //         song
    //     });
    // }
    // if (album !== null) {
    //     artistAlbumSongCombos.push({
    //         artist: artists[0],
    //         album: null,
    //         song
    //     });
    // }

    let foundStats = [];
    for (let index in artistAlbumSongCombos) {
        let combo = artistAlbumSongCombos[index];
        let lrcLibLyricsPromise = getLyricLibLyrics(combo.artist, combo.song, combo.album, duration);

        let mxmError = null;

        try {
            let musixmatchLyrics = await mx.getLrc(videoId, combo.artist, combo.song, combo.album, lrcLibLyricsPromise, tokenPromise);
            if (musixmatchLyrics) {
                response.musixmatchWordByWordLyrics = musixmatchLyrics.richSynced;
                response.musixmatchSyncedLyrics = musixmatchLyrics.synced;
                response.debugInfo = musixmatchLyrics.debugInfo;
            }
        } catch (e) {
            mxmError = e;
        }

        const lrcLibLyrics = await lrcLibLyricsPromise;
        response.lrclibSyncedLyrics = lrcLibLyrics?.synced;
        response.lrclibPlainLyrics = lrcLibLyrics?.unsynced;


        foundStats.push({
            'hasWordByWord': isTruthy(response.musixmatchWordByWordLyrics),
            'hasLrcLibSynced': isTruthy(response.lrclibSyncedLyrics),
            'hasMusixmatchSynced': isTruthy(response.musixmatchSyncedLyrics),
            'hasLrcLibPlain': isTruthy(response.lrclibPlainLyrics),
            'musixMatchError': mxmError
        });

        if (isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics)) {
            response.song = combo.song;
            response.artist = combo.artist;
            response.album = combo.album;
            break;
        }
    }

    observe({
        combos: artistAlbumSongCombos,
        foundStats: foundStats,
        foundSyncedLyrics: isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics),
        foundPlainLyrics: isTruthy(response.lrclibPlainLyrics),
        foundRichSyncedLyrics: isTruthy(response.musixmatchSyncedLyrics),
        foundLyrics: isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics) || isTruthy(response.lrclibPlainLyrics),
        response: response
    });



    let json = JSON.stringify(response);

    let cacheableResponse = new Response(json, { status: 200 });
    if (response.musixmatchSyncedLyrics || response.lrclibSyncedLyrics) {
        cacheableResponse.headers.set('Cache-control', 'public; max-age=259200');
    } else {
        // cache the request only for a short time
        cacheableResponse.headers.set("Cache-control", "public; max-age=600");
    }
    cacheableResponse.headers.set('Content-Type', 'application/json');
    awaitLists.add(cache.put(request.url, cacheableResponse));

    return new Response(json, { status: 200 });
}


function cleanupText(text: string | null | undefined): string | null | undefined {
    if (!text) return text;

    // Common language-related terms to preserve
    const languageTerms = [
        'ver', 'version', 'remix',
        'english', 'korean', 'japanese', 'chinese',
        'jp', 'kr', 'cn', 'en',
        '日本語', '한국어', '中文', 'español',
        'instrumental', 'vault', 'fast', 'slow',
        'with', 'from', 'acoustic'
    ];
    const languagePattern = new RegExp(languageTerms.join('|'), 'i');

    let result = text;
    let lastResult = '';
    let i = 0;

    while (result !== lastResult && i < 10) {
        i++;
        lastResult = result;
        result = result
            .replace(/\[([^\[\]]*)\]/g, (match, content) => {
                // If it contains language-related terms, keep the brackets
                return languagePattern.test(content) ? match : `(${content})`;
            })
            .replace(/(?!^|\s)\(([^()]*)\)/g, (match, content) => {
                // Handle existing parentheses
                return languagePattern.test(content) ? match : '';
            })
            .replace(/\s+/g, ' ')
            .trim();
    }


    return result;
}

function isTruthy(value: string | null | undefined): boolean {
    return !(value === null || value === undefined);
}

